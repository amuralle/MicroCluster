#Alex Muralles & Ruhani Mumick
#02-512 Final Project
#KCutSolver.py


from datetime import datetime
import random as rand
import sys
from scipy import stats
from operator import itemgetter
import itertools

#Implementations for brute force, greedy algorithm, and
#Branch-and-bound methods (if time allows) for solving the min cut to
#Cluster genes


#Graph representation:
    #G = {node1,node2,node3,node4......nodeX}
    #E (edge set) = [(node1,node2,weight),(node3,node4,weight)]


#Node object, to use for the graph implementation
class node(object):

    def __init__(self,name, data = [], data2 = []):
        self.geneName = name
        self.edges = list()
        self.control = data
        self.variable = data2

    def add_edge(self,other):
        self.edges.append(other)

    def remove_edge(self,other):
        if (other in self.edges):
            self.edges.remove(other)

    def __eq__(self,other):
        if type(other) == str:
            return self.geneName == other
        else:
            return (self.geneName == other.geneName)

#Node helper functions

def removeEdge(node1,node2):
    node1.remove_edge(node2)
    node2.remove_edge(node1)

def connect(node1,node2):
    node1.add_edge(node2)
    node2.add_edge(node1)


#Pearson Correlation Coefficent helper function

def calculateC(list1, list2,k):
    #To calculate C, we are going to use a package, but we have to handle
    #for cases in which the denominator is equal to 0 (which occured in test cases)
    #Using Lside and Rside to denote left and right sides of the provided formula
    n = (k*(k-1))/2.00
    sum1 = sum(list1)
    sum1 = sum1**2
    list1Squared = []
    for i in list1:
        list1Squared.append(i**2)
    squaredSum1 = sum(list1Squared)

    if(((n * squaredSum1) - sum1) == 0):
        return 0.00

    sum2 = sum(list2)
    sum2 = sum2**2
    list2Squared = []
    for i in list2:
        list2Squared.append(i**2)
    squaredSum2 = sum(list2Squared)

    if(((n * squaredSum2) - sum2) == 0):
        return 0.00

    return stats.pearsonr(list1,list2)[0]

#Weight function

def weight(node1,node2):
    dataControl1 = node1.control
    dataControl2 = node2.control
    dataVariable1 = node1.variable
    dataVariable2 = node2.variable


    x = [0] * len(dataControl1)
    y = [0] * len(dataControl2)

    for i in range(len(dataControl1)):
        x[i] = (dataControl1[i] - dataVariable1[i]) ** 2
        y[i] = (dataControl2[i] - dataVariable2[i]) ** 2

    return calculateC(x,y,3)

#Small helper function for file input
def turnToFloats(aList):
    newList = []
    for item in aList:
        newList.append(float(item))
    return newList



#Build the graph by parsing a gene ontology file, generated by using
#The parsing snippets of code features in finalProjectR.txt
def buildGraph(fileOpener, threshold):
    theFile = open(fileOpener)
    G = []
    allNodes = []
    E = []
    header = True
    for line in theFile.readlines():


        if header:
            header = False
            continue

        lineList = line.split()
        if len(lineList) != 21 or "NA NA" in line:
            continue

        name = lineList[2]
        variable1 = turnToFloats(lineList[3:6])
        control1 = turnToFloats(lineList[6:9])
        variable2 = turnToFloats(lineList[9:12])
        control2 = turnToFloats(lineList[12:15])
        variable3 = turnToFloats(lineList[15:18])
        control3 = turnToFloats(lineList[18:])

        variable = [(sum(variable1)/3), sum(variable2)/3, sum(variable3)/3 ]
        control = [(sum(control1)/3), (sum(control2)/3), (sum(control3)/3)]
        newNode = node(name,variable,control)
        G.append(newNode)
        allNodes.append(newNode)

    doneNodes = []

    for i in range(len(G)):
        for j in range(i+1,len(G)):
            node2 = G[j]
            node1 = G[i]
            w = abs(weight(node1,node2))
            if w >= threshold:
                E.append((node1, node2,w))
                E.append((node2, node1,w))
                connect(node1,node2)
    return G,E


#Modification of breadth first search to find clusters
def findClusters(G):
    graph = []
    for item in G:
        graph.append(item)
    C = []
    while graph != []:
        toDo = []
        done = []
        nodeToStart = rand.randint(0,len(graph)-1)
        startNode = graph[nodeToStart]
        for node in startNode.edges:
            toDo.append(node)
        done.append(startNode)

        while toDo != []:
            nodeA = toDo[0]
            toDo.remove(nodeA)
            done.append(nodeA)
            for eachNode in nodeA.edges:
                if(eachNode not in done and eachNode not in toDo):
                    toDo.append(eachNode)

        for eachNode in done:
            if eachNode in graph:
                graph.remove(eachNode)

        C.append(done)
    #Find the clusters in a graph using
    #an altered version of breadth-first search
    return C


#Greedy Algorithm, see pseudocode in documentation file (report)
def solveGreedy(G,E,K):
    print("Starting SolveGreedy")
    Gcopy = list(G)
    assert(K <= len(G))
    cost = 0
    c = len(findClusters(G))
    E.sort(key = itemgetter(2))
    if c > K:
        error = ("Error: graph already has more clusters than requested, k = " + str(c))
        sys.exit(error)

    while c < K:
        edgeToRemove = E[0]
        edgeToRemoveCopy = E[1]
        E.remove(edgeToRemove)
        E.remove(edgeToRemoveCopy)
        removeEdge(edgeToRemove[0],edgeToRemove[1])
        cost = cost + edgeToRemove[2]
        c = len(findClusters(G))
    clusters = findClusters(G)

    return clusters, G, E, cost
    #Solve for k-cuts using a greedy algorithm


def powerset(L):
  pset = set()
  for n in xrange(len(L) + 1):
    for sset in itertools.combinations(L, n):
      pset.add(sset)
  return list(pset)

#Brute Force Algorithm, see psuedocode in documentation file (report)
def solveBruteForce(G,E, K, threshold = 0):
    #To solve brute firce, first we need to generate every set of edges to "cut"
    #This is the powerset of the edge set
    print("Starting BruteForce")
    allPossibleEdges = powerset(E[::2])
    print("Have edges")
    #Note that to avoid the same cuts, we must only consider one half of our edge set
    #This is because the edge set has copies of itself ordered within it
    bestCut = []
    lowestCost = 99999999999999999999
    #Should be arbitrarily high enough. Would be nice to find a formal int_max in python..
    #Because there are discrepancies between python2 and python3 of intMax, we will use
    #This instead to avoid any confusion, otherwise sys.maxint or sys.maxsize would be used
    for possibleCut in allPossibleEdges:
        #We consider every possible cut
        propogatedCost = 0
        for cut in possibleCut:
            #Make the cut
            node1 = cut[0]
            node2 = cut[1]
            cost = cut[2]
            propogatedCost = propogatedCost + cost
            removeEdge(node1,node2)
            E.remove(cut)

        c = (findClusters(G))
        if len(c) == K and propogatedCost < lowestCost:
            lowestCost = propogatedCost
            bestCut = possibleCut

        if lowestCost < threshold:
            return c,G,E,lowestCost

        #Repair our edge set
        for cut in possibleCut:
            connect(cut[0],cut[1])
            E.append(cut)

    c = findClusters(G)
    for cut in bestCut:
        #Make the cut again
        node1 = cut[0]
        node2 = cut[1]
        removeEdge(node1,node2)
        E.remove(cut)

    return c,G,E,lowestCost




#Test case code

#G,E = buildGraph("random100.txt",0.7)
#C,G,E,cost = solveGreedy(G,E,20)
#outputFile = open("kCutSolverOutput.txt","w")
#header = "CLUSTER\tGENE\n"
#outputFile.write(header)



#Init function & input
def init():
    startTime = datetime.now()
    textFile = sys.argv[1]
    k = int(sys.argv[2])
    functionOption = sys.argv[3]
    edgeThreshold = float(sys.argv[4])

    print("Generating Graph...")
    G,E = buildGraph(textFile, edgeThreshold)
    print("Done")
    if functionOption == "1":
        C,G,E,cost = solveGreedy(G,E,k)

    elif functionOption == "2":
        if len(sys.argv) == 6:
            threshold = int(sys.argv[5])
            C,G,E,cost = solveBruteForce(G,E,k,threshold)
        else:
            C,G,E,cost = solveBruteForce(G,E,k)

    else:
        print("INVALID INPUT: PLEASE FOLLOW THE FOLLOWING INPUT:\n" +
              "python kCutSolver.py [Processed Microarray Filename (see documentation)] [k] [function Option (1,2)] [Edge Threshold] [Cost Threshold (for brute force only)]")


    outputFile = open("kCutSolverOutput.txt","w")
    header = "#CLUSTER\tGENE\tPROPOGATED COST = " + str(cost) + "\n"
    outputFile.write(header)

    for i in range(len(C)):
        cluster = C[i]
        outputFile.write("CLUSTER " + str(i+1) + "\n")
        for eachNode in cluster:
            outputFile.write(("\t" + eachNode.geneName + "\n"))

    print("Runtime")
    print(datetime.now() - startTime)
    print("Done, output in kCutSolverOutput.txt")
    return 0

init()
